%{
    use Pg::SQL::Parser::Element;
    my $factory = Pg::SQL::Parser::Element->new();
%}

/* %left OR */
%left AND
/* %left NOT */
%right '='
%left '<' '>'
%left LIKE ILIKE
%left BETWEEN
%left OPERATOR_NAME
%left '+' '-'
%left '*' '/' '%'
%left '^'
%left '(' ')'
%left '::'

%%

top: statements                { $_[1] }
;

statements: statement          { [ $_[1] ] }
    | statements ';' statement { push @{ $_[1] }, $_[3]; $_[1] }
    | statements ';'           { $_[1] }
;

statement: select_stmt         { $_[1] }
;

select_stmt: SELECT result_columns { $factory->make( 'Select', results => $_[2] ) }
;

result_columns: result_column          { [ $_[1] ] }
    | result_columns ',' result_column { push @{ $_[1] }, $_[3]; $_[1] }
;

result_column: expr      { $factory->make( 'Result_Column', 'value' => $_[1] ) }
    | expr AS identifier { $factory->make( 'Result_Column', 'value' => $_[1], 'alias' => $_[3] ) }
;

expr: expr_simple                      { $_[1] }
    | operator_expression              { $_[1] }
    | cast_expression                  { $_[1] }
    | function_expression              { $_[1] }
    | column_expression                { $_[1] }
;

column_expression: identifier                   { $factory->make( 'Column', 'name' => $_[1] ) }
    | identifier '.' identifier                 { $factory->make( 'Column', 'name' => $_[3], 'source' => [ $_[1] ] ) }
    | identifier '.' identifier '.' identifier  { $factory->make( 'Column', 'name' => $_[5], 'source' => [ $_[1], $_[3] ] ) }
;

function_expression: function_name '(' function_args ')' { $_[1]->arguments( $_[3] ); $_[1] }
;

function_name: identifier           { $factory->make( 'Function', 'name' => $_[1] ) }
    | identifier '.' identifier     { $factory->make( 'Function', 'name' => $_[3], 'schema' => $_[1] ) }
;

function_args: expr                 { [ $_[1] ] }
    | function_args ',' expr        { push @{ $_[1] }, $_[3]; $_[1] }
    | /* EMPTY */                   { [] }
;

operator_expression: expr BETWEEN expr AND expr  { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => [ $_[3], $_[5] ] ) }
    | expr OPERATOR_NAME                         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1] ) }
    | OPERATOR_NAME expr                         { $factory->make( 'Operation', 'operator' => $_[1], 'right' => $_[2] ) }
    | expr '+' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '-' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '*' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '%' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '/' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '<' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '>' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '=' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '^' expr                              { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr LIKE expr                             { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr ILIKE expr                            { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr OPERATOR_NAME expr                    { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
;

cast_expression: expr '::' normal_type { $factory->make( 'Cast', 'method' => '::', 'value' => $_[1], 'final_type' => $_[3] ) }
    | CAST '(' expr AS normal_type ')' { $factory->make( 'Cast', 'method' => 'sql', 'value' => $_[3], 'final_type' => $_[5] ) }
    | normal_type literal_value        { $factory->make( 'Cast', 'method' => 'function', 'value' => $_[2], 'final_type' => $_[1] ) }
;

expr_simple: literal_value         { $_[1] }
    | '(' expr ')'                 { $_[2] }
;

literal_value: STRING_CONSTANT  { $factory->make( 'Literal_Value', 'type', => 'STRING_CONSTANT',     'value' => $_[1] ) }
    | USTRING_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'USTRING_CONSTANT',    'value' => $_[1] ) }
    | ESTRING_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'ESTRING_CONSTANT',    'value' => $_[1] ) }
    | BITSTRING_CONSTANT        { $factory->make( 'Literal_Value', 'type', => 'BITSTRING_CONSTANT',  'value' => $_[1] ) }
    | XBITSTRING_CONSTANT       { $factory->make( 'Literal_Value', 'type', => 'XBITSTRING_CONSTANT', 'value' => $_[1] ) }
    | NUMERIC_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'NUMERIC_CONSTANT',    'value' => $_[1] ) }
    | INTEGER_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'INTEGER_CONSTANT',    'value' => $_[1] ) }
;

identifier: QUOTED_IDENTIFIER { $_[1] }
    | UQUOTED_IDENTIFIER      { $_[1] }
    | IDENTIFIER              { $_[1] }
    | keywords_notreserved    { $_[1] }
;

normal_type: simple_type                                     { $_[1] }
    | NUMERIC '(' INTEGER_CONSTANT ')'                       { $factory->make( 'Type', 'name' => $_[1], 'limits' => [ $_[3] ] ) }
    | NUMERIC '(' INTEGER_CONSTANT ',' INTEGER_CONSTANT ')'  { $factory->make( 'Type', 'name' => $_[1], 'limits' => [ $_[3], $_[5] ] ) }
    | DECIMAL '(' INTEGER_CONSTANT ')'                       { $factory->make( 'Type', 'name' => $_[1], 'limits' => [ $_[3] ] ) }
    | DECIMAL '(' INTEGER_CONSTANT ',' INTEGER_CONSTANT ')'  { $factory->make( 'Type', 'name' => $_[1], 'limits' => [ $_[3], $_[5] ] ) }
    | VARCHAR '(' INTEGER_CONSTANT ')'                       { $factory->make( 'Type', 'name' => $_[1], 'limits' => [ $_[3] ] ) }
    | timestamp_type                                         { $_[1] }
    | time_type                                              { $_[1] }
    | interval_type                                          { $_[1] }
;

simple_type: base_type                                       { $_[1] }
    | identifier '.' base_type                               { $_[3]->schema( $_[1] ); $_[3] }
;

base_type: identifier                                        { $factory->make( 'Type', 'name' => $_[1] ) }
    | keywords_reserved_ok_for_functions_or_types            { $factory->make( 'Type', 'name' => $_[1] ) }
    | keywords_notreserved_not_ok_for_functions_or_types     { $factory->make( 'Type', 'name' => $_[1] ) }
    | DOUBLE PRECISION                                       { $factory->make( 'Type', 'name' => 'double precision' ) }
;

timestamp_type: TIMESTAMP WITH TIME ZONE                                           { $factory->make( 'Type', 'name' => 'timestamp with time zone' ) }
    | TIMESTAMP WITHOUT TIME ZONE                                        { $factory->make( 'Type', 'name' => 'timestamp without time zone' ) }
    | TIMESTAMP '(' INTEGER_CONSTANT ')'                                 { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'timestamp' ) }
    | TIMESTAMP '(' INTEGER_CONSTANT ')' WITH TIME ZONE                  { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'timestamp with time zone' ) }
    | TIMESTAMP '(' INTEGER_CONSTANT ')' WITHOUT TIME ZONE               { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'timestamp without time zone' ) }
;

time_type: TIME WITH TIME ZONE                                      { $factory->make( 'Type', 'name' => 'time with time zone' ) }
    | TIME WITHOUT TIME ZONE                                   { $factory->make( 'Type', 'name' => 'time without time zone' ) }
    | TIME '(' INTEGER_CONSTANT ')'                            { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'time' ) }
    | TIME '(' INTEGER_CONSTANT ')' WITH TIME ZONE             { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'time with time zone' ) }
    | TIME '(' INTEGER_CONSTANT ')' WITHOUT TIME ZONE          { $factory->make( 'Type', 'limits' => [ $_[3] ], 'name' => 'time without time zone' ) }
;

interval_type: INTERVAL '(' INTEGER_CONSTANT ')'                    { $factory->make( 'Type', 'name' => 'interval', 'limits' => [ $_[3] ] ) }
    | base_interval_type YEAR                                       { $_[1]->name( $_[1]->name() . ' year' ); $_[1] }
    | base_interval_type MONTH                                      { $_[1]->name( $_[1]->name() . ' month' ); $_[1] }
    | base_interval_type DAY                                        { $_[1]->name( $_[1]->name() . ' day' ); $_[1] }
    | base_interval_type HOUR                                       { $_[1]->name( $_[1]->name() . ' hour' ); $_[1] }
    | base_interval_type MINUTE                                     { $_[1]->name( $_[1]->name() . ' minute' ); $_[1] }
    | base_interval_type SECOND                                     { $_[1]->name( $_[1]->name() . ' second' ); $_[1] }
    | base_interval_type YEAR TO MONTH                              { $_[1]->name( $_[1]->name() . ' year to month' ); $_[1] }
    | base_interval_type DAY TO HOUR                                { $_[1]->name( $_[1]->name() . ' day to hour' ); $_[1] }
    | base_interval_type DAY TO MINUTE                              { $_[1]->name( $_[1]->name() . ' day to minute' ); $_[1] }
    | base_interval_type DAY TO SECOND                              { $_[1]->name( $_[1]->name() . ' day to second' ); $_[1] }
    | base_interval_type HOUR TO MINUTE                             { $_[1]->name( $_[1]->name() . ' hour to minute' ); $_[1] }
    | base_interval_type HOUR TO SECOND                             { $_[1]->name( $_[1]->name() . ' hour to second' ); $_[1] }
    | base_interval_type MINUTE TO SECOND                           { $_[1]->name( $_[1]->name() . ' minute to second' ); $_[1] }
    | base_interval_type SECOND '(' INTEGER_CONSTANT ')'            {
                                                                        my $l = $_[1]->limits() // [];
                                                                        $l->[1] = $_[4];
                                                                        $_[1]->limits( $l );
                                                                        $_[1]->name( $_[1]->name() . ' second' );
                                                                        $_[1]
                                                                    }
    | base_interval_type DAY TO SECOND '(' INTEGER_CONSTANT ')'     {
                                                                        my $l = $_[1]->limits() // [];
                                                                        $l->[1] = $_[6];
                                                                        $_[1]->limits( $l );
                                                                        $_[1]->name( $_[1]->name() . ' day to second' );
                                                                        $_[1]
                                                                    }
    | base_interval_type HOUR TO SECOND '(' INTEGER_CONSTANT ')'    {
                                                                        my $l = $_[1]->limits() // [];
                                                                        $l->[1] = $_[6];
                                                                        $_[1]->limits( $l );
                                                                        $_[1]->name( $_[1]->name() . ' hour to second' );
                                                                        $_[1]
                                                                    }
    | base_interval_type MINUTE TO SECOND '(' INTEGER_CONSTANT ')'  {
                                                                        my $l = $_[1]->limits() // [];
                                                                        $l->[1] = $_[6];
                                                                        $_[1]->limits( $l );
                                                                        $_[1]->name( $_[1]->name() . ' minute to second' );
                                                                        $_[1]
                                                                    }
;

base_interval_type: INTERVAL               { $factory->make( 'Type', 'name' => 'interval' ) }
    | INTERVAL '(' INTEGER_CONSTANT ')'    { $factory->make( 'Type', 'name' => 'interval', 'limits' => [ $_[3] ] ) }
;

keywords_notreserved: ABORT
    | ABSOLUTE
    | ACCESS
    | ACTION
    | ADD
    | ADMIN
    | AFTER
    | AGGREGATE
    | ALSO
    | ALTER
    | ALWAYS
    | ASSERTION
    | ASSIGNMENT
    | AT
    | ATTRIBUTE
    | BACKWARD
    | BEFORE
    | BEGIN
    | BY
    | CACHE
    | CALLED
    | CASCADE
    | CASCADED
    | CATALOG
    | CHAIN
    | CHARACTERISTICS
    | CHECKPOINT
    | CLASS
    | CLOSE
    | CLUSTER
    | COLLATION
    | COMMENT
    | COMMENTS
    | COMMIT
    | COMMITTED
    | CONFIGURATION
    | CONNECTION
    | CONSTRAINTS
    | CONTENT
    | CONTINUE
    | CONVERSION
    | COPY
    | COST
    | CSV
    | CURRENT
    | CURSOR
    | CYCLE
    | DATA
    | DATABASE
    | DAY
    | DEALLOCATE
    | DECLARE
    | DEFAULTS
    | DEFERRED
    | DEFINER
    | DELETE
    | DELIMITER
    | DELIMITERS
    | DICTIONARY
    | DISABLE
    | DISCARD
    | DOCUMENT
    | DOMAIN
    | DOUBLE
    | DROP
    | EACH
    | ENABLE
    | ENCODING
    | ENCRYPTED
    | ENUM
    | ESCAPE
    | EXCLUDE
    | EXCLUDING
    | EXCLUSIVE
    | EXECUTE
    | EXPLAIN
    | EXTENSION
    | EXTERNAL
    | FAMILY
    | FIRST
    | FOLLOWING
    | FORCE
    | FORWARD
    | FUNCTION
    | FUNCTIONS
    | GLOBAL
    | GRANTED
    | HANDLER
    | HEADER
    | HOLD
    | HOUR
    | IDENTITY
    | IF
    | IMMEDIATE
    | IMMUTABLE
    | IMPLICIT
    | INCLUDING
    | INCREMENT
    | INDEX
    | INDEXES
    | INHERIT
    | INHERITS
    | INLINE
    | INPUT
    | INSENSITIVE
    | INSERT
    | INSTEAD
    | INVOKER
    | ISOLATION
    | KEY
    | LABEL
    | LANGUAGE
    | LARGE
    | LAST
    | LC_COLLATE
    | LC_CTYPE
    | LEVEL
    | LISTEN
    | LOAD
    | LOCAL
    | LOCATION
    | LOCK
    | MAPPING
    | MATCH
    | MAXVALUE
    | MINUTE
    | MINVALUE
    | MODE
    | MONTH
    | MOVE
    | NAME
    | NAMES
    | NEXT
    | NO
    | NOTHING
    | NOTIFY
    | NOWAIT
    | NULLS
    | OBJECT
    | OF
    | OFF
    | OIDS
    | OPERATOR
    | OPTION
    | OPTIONS
    | OWNED
    | OWNER
    | PARSER
    | PARTIAL
    | PARTITION
    | PASSING
    | PASSWORD
    | PLANS
    | PRECEDING
    | PREPARE
    | PREPARED
    | PRESERVE
    | PRIOR
    | PRIVILEGES
    | PROCEDURAL
    | PROCEDURE
    | QUOTE
    | RANGE
    | READ
    | REASSIGN
    | RECHECK
    | RECURSIVE
    | REF
    | REINDEX
    | RELATIVE
    | RELEASE
    | RENAME
    | REPEATABLE
    | REPLACE
    | REPLICA
    | RESET
    | RESTART
    | RESTRICT
    | RETURNS
    | REVOKE
    | ROLE
    | ROLLBACK
    | ROWS
    | RULE
    | SAVEPOINT
    | SCHEMA
    | SCROLL
    | SEARCH
    | SECOND
    | SECURITY
    | SEQUENCE
    | SEQUENCES
    | SERIALIZABLE
    | SERVER
    | SESSION
    | SET
    | SHARE
    | SHOW
    | SIMPLE
    | STABLE
    | STANDALONE
    | START
    | STATEMENT
    | STATISTICS
    | STDIN
    | STDOUT
    | STORAGE
    | STRICT
    | STRIP
    | SYSID
    | SYSTEM
    | TABLES
    | TABLESPACE
    | TEMP
    | TEMPLATE
    | TEMPORARY
    | TEXT
    | TRANSACTION
    | TRIGGER
    | TRUNCATE
    | TRUSTED
    | TYPE
    | UNBOUNDED
    | UNCOMMITTED
    | UNENCRYPTED
    | UNKNOWN
    | UNLISTEN
    | UNLOGGED
    | UNTIL
    | UPDATE
    | VACUUM
    | VALID
    | VALIDATE
    | VALIDATOR
    | VALUE
    | VARYING
    | VERSION
    | VIEW
    | VOLATILE
    | WHITESPACE
    | WITHOUT
    | WORK
    | WRAPPER
    | WRITE
    | XML
    | YEAR
    | YES
    | ZONE
;

keywords_reserved_ok_for_functions_or_types: AUTHORIZATION
    | BINARY
    | CONCURRENTLY
    | CROSS
    | CURRENT_SCHEMA
    | FREEZE
    | FULL
    | ILIKE
    | INNER
    | IS
    | ISNULL
    | JOIN
    | LEFT
    | LIKE
    | NATURAL
    | NOTNULL
    | OUTER
    | OVER
    | OVERLAPS
    | RIGHT
    | SIMILAR
    | VERBOSE
;

keywords_notreserved_not_ok_for_functions_or_types: BETWEEN
    | BIGINT
    | BIT
    | BOOLEAN
    | CHAR
    | CHARACTER
    | COALESCE
    | DEC
    | DECIMAL
    | EXISTS
    | EXTRACT
    | FLOAT
    | GREATEST
    | INOUT
    | INT
    | INTEGER
    | INTERVAL
    | LEAST
    | NATIONAL
    | NCHAR
    | NONE
    | NULLIF
    | NUMERIC
    | OUT
    | OVERLAY
    | POSITION
    | PRECISION
    | REAL
    | ROW
    | SETOF
    | SMALLINT
    | SUBSTRING
    | TIME
    | TIMESTAMP
    | TREAT
    | TRIM
    | VALUES
    | VARCHAR
    | XMLATTRIBUTES
    | XMLCONCAT
    | XMLELEMENT
    | XMLEXISTS
    | XMLFOREST
    | XMLPARSE
    | XMLPI
    | XMLROOT
    | XMLSERIALIZE
;

%%

# vim: set ft=lex:

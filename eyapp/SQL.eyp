%{
    use Pg::SQL::Parser::Element;
    my $factory = Pg::SQL::Parser::Element->new();
%}

/* %left OR */
%left AND
/* %left NOT */
%right '='
%left '<' '>'
%left LIKE ILIKE
%left BETWEEN
%left OPERATOR
%left '+' '-'
%left '*' '/' '%'
%left '^'

%%

top: statements                { $_[1] }
;

statements: statement          { [ $_[1] ] }
    | statements ';' statement { push @{ $_[1] }, $_[3]; $_[1] }
    | statements ';'           { $_[1] }
;

statement: select_stmt         { $_[1] }
;

select_stmt: SELECT result_columns {
                                        my $select = $factory->make( 'Select' );
                                        for my $rc ( @{ $_[2] } ) {
                                            my $res = $factory->make('Result_Column');
                                            $res->value( $rc->[0] );
                                            $res->alias( $rc->[1] ) if defined $rc->[1];
                                            $select->add_result( $res )
                                        }
                                        $select
                                    }
;

result_columns: result_column          { [ $_[1] ] }
    | result_columns ',' result_column { push @{ $_[1] }, $_[3]; $_[1] }
;

result_column: expr      { [ $_[1], undef ] }
    | expr AS identifier { [ $_[1], $_[3] ] }
;

expr: expr_simple           { $_[1] }
    | expr_simple BETWEEN expr AND expr { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => [ $_[3], $_[5] ] ) }
    | expr OPERATOR         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1] ) }
    | OPERATOR expr         { $factory->make( 'Operation', 'operator' => $_[1], 'right' => $_[2] ) }
    | expr '+' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '-' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '*' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '%' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '/' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '<' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '>' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '=' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr '^' expr         { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr LIKE expr        { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr ILIKE expr       { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
    | expr OPERATOR expr    { $factory->make( 'Operation', 'operator' => $_[2], 'left' => $_[1], 'right' => $_[3] ) }
;

expr_simple: literal_value         { $_[1] }
    | '(' expr ')'                 { $_[2] }
;

literal_value: STRING_CONSTANT  { $factory->make( 'Literal_Value', 'type', => 'STRING_CONSTANT',     'value' => $_[1] ) }
    | USTRING_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'USTRING_CONSTANT',    'value' => $_[1] ) }
    | ESTRING_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'ESTRING_CONSTANT',    'value' => $_[1] ) }
    | BITSTRING_CONSTANT        { $factory->make( 'Literal_Value', 'type', => 'BITSTRING_CONSTANT',  'value' => $_[1] ) }
    | XBITSTRING_CONSTANT       { $factory->make( 'Literal_Value', 'type', => 'XBITSTRING_CONSTANT', 'value' => $_[1] ) }
    | NUMERIC_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'NUMERIC_CONSTANT',    'value' => $_[1] ) }
    | INTEGER_CONSTANT          { $factory->make( 'Literal_Value', 'type', => 'INTEGER_CONSTANT',    'value' => $_[1] ) }
;

identifier: QUOTED_IDENTIFIER { $_[1] }
    | UQUOTED_IDENTIFIER      { $_[1] }
    | IDENTIFIER              { $_[1] }
;

%%

# vim: set ft=lex:
